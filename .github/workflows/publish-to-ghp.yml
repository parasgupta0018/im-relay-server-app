name: Publish to GitHub Packages with Caching

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: 'NPM package name to mirror (e.g., "axios" or "@scope/pkg")'
        required: true
      package_version:
        description: 'Package version to mirror (e.g., "latest" or a specific version)'
        required: true
        default: 'latest'

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # Permission to publish to GitHub Packages
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'

      - name: Sanitize Package Name
        id: sanitize_name
        run: |
          # This step removes the version from the package name if the user accidentally includes it.
          # It correctly handles both regular and scoped packages 
          SANITIZED_NAME=$(echo "${{ github.event.inputs.package_name }}" | sed 's/@\([^@]*\)$//')
          echo "Original package name input: ${{ github.event.inputs.package_name }}, Version: ${{ github.event.inputs.package_version }}"
          echo "Sanitized package name: $SANITIZED_NAME"
          echo "sanitized_name=$SANITIZED_NAME" >> $GITHUB_OUTPUT

      - name: Resolve package version
        id: resolve_version
        run: |
          if [ "${{ github.event.inputs.package_version }}" = "latest" ]; then
            # Get the actual latest version number using the sanitized package name
            ACTUAL_VERSION=$(npm view ${{ steps.sanitize_name.outputs.sanitized_name }} version --registry=https://registry.npmjs.org/)
            echo "resolved_version=$ACTUAL_VERSION" >> $GITHUB_OUTPUT
          else
            echo "resolved_version=${{ github.event.inputs.package_version }}" >> $GITHUB_OUTPUT
          fi
          echo "Resolved version: $(echo $ACTUAL_VERSION)"

      - name: Cache NPM Package and Dependencies
        id: cache_package
        uses: actions/cache@v4
        with:
          path: |
            ./cached-packages
            ./dependency-cache
          key: npm-package-with-deps-${{ steps.sanitize_name.outputs.sanitized_name }}-${{ steps.resolve_version.outputs.resolved_version }}
          restore-keys: |
            npm-package-with-deps-${{ steps.sanitize_name.outputs.sanitized_name }}-

      - name: Download Package and All Dependencies from NPM
        if: steps.cache_package.outputs.cache-hit != 'true'
        run: |
          echo "Cache miss - downloading package and all dependencies from NPM registry"
          mkdir -p cached-packages dependency-cache temp-workspace
          
          # Create a temporary package.json to install the target package and get all dependencies
          cd temp-workspace
          cat > package.json << EOF
          {
            "name": "temp-installer",
            "version": "1.0.0",
            "dependencies": {
              "${{ steps.sanitize_name.outputs.sanitized_name }}": "${{ steps.resolve_version.outputs.resolved_version }}"
            }
          }
          EOF
          
          # Install the package and all its dependencies
          echo "Installing ${{ steps.sanitize_name.outputs.sanitized_name }}@${{ steps.resolve_version.outputs.resolved_version }} and all dependencies..."
          npm install --registry=https://registry.npmjs.org/ --no-audit --no-fund
          
          # Create dependency list
          echo "Generating dependency list..."
          npm list --json --all > ../dependency-cache/dependency-tree.json
          
          # Extract all packages from node_modules and pack them
          echo "Packing all dependencies..."
          WORKSPACE_ROOT=$(pwd)
          cd node_modules
          
          # Use a different approach to avoid subshell issues with while loop
          find . -name "package.json" -type f > ../dependency-cache/package-list.txt
          
          while IFS= read -r pkg_json; do
            pkg_dir=$(dirname "$pkg_json")
            original_dir=$(pwd)
            cd "$pkg_dir"
            
            # Get package info
            pkg_name=$(node -p "require('./package.json').name" 2>/dev/null) || continue
            pkg_version=$(node -p "require('./package.json').version" 2>/dev/null) || continue
            
            # Skip the main package - we handle it separately
            if [ "$pkg_name" = "${{ steps.sanitize_name.outputs.sanitized_name }}" ]; then
              echo "Skipping main package: $pkg_name@$pkg_version (handled separately)"
              cd "$original_dir"
              continue
            fi
            
            echo "Processing dependency: $pkg_name@$pkg_version"
            
            # Create safe filename for caching
            safe_name=$(echo "$pkg_name" | sed 's/[@\/]/_/g')
            
            # Pack the package
            if npm pack --quiet 2>/dev/null; then
              # Move the packed file to our cache using absolute path
              tgz_file=$(ls *.tgz 2>/dev/null | head -1)
              if [ -n "$tgz_file" ]; then
                mv "$tgz_file" "${WORKSPACE_ROOT}/../dependency-cache/${safe_name}-${pkg_version}.tgz"
                echo "Cached: ${safe_name}-${pkg_version}.tgz"
              fi
            else
              echo "Failed to pack: $pkg_name@$pkg_version"
            fi
            
            cd "$original_dir"
          done < ../dependency-cache/package-list.txt
          
          # Also handle the main package separately for publishing
          cd "${WORKSPACE_ROOT}/../cached-packages"
          npm pack ${{ steps.sanitize_name.outputs.sanitized_name }}@${{ steps.resolve_version.outputs.resolved_version }} --registry=https://registry.npmjs.org/
          
          # Extract and modify the main package
          tar -xzf ${{ steps.sanitize_name.outputs.sanitized_name }}-${{ steps.resolve_version.outputs.resolved_version }}.tgz
          cd package
          cp package.json package.json.backup
          
          # Update package.json with scoped name and publishConfig
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const originalName = pkg.name;
            pkg.name = '@${{ github.repository_owner }}/' + '${{ steps.sanitize_name.outputs.sanitized_name }}'.split('/').pop();
            pkg.publishConfig = { registry: 'https://npm.pkg.github.com' };
            if (!pkg.repository) {
              pkg.repository = {
                type: 'git',
                url: 'git+https://github.com/${{ github.repository }}.git'
              };
            }
            if (pkg.scripts) {
              const scriptsToRemove = ['test', 'prepublishOnly', 'prepack', 'postpack', 'prepare'];
              scriptsToRemove.forEach(script => {
                if (pkg.scripts[script]) {
                  console.log('Removing script:', script);
                  delete pkg.scripts[script];
                }
              });
              Object.keys(pkg.scripts).forEach(scriptName => {
                if (scriptName.includes('test') || scriptName.includes('build')) {
                  console.log('Removing potentially problematic script:', scriptName);
                  delete pkg.scripts[scriptName];
                }
              });
            }
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
            console.log('Updated package name from', originalName, 'to', pkg.name);
          "
          
          cd ../../
          echo "Package and all dependencies downloaded, modified, and cached"
          echo "Cached packages count: $(ls -1 dependency-cache/*.tgz 2>/dev/null | wc -l)"

      - name: Use Cached Package and Dependencies
        if: steps.cache_package.outputs.cache-hit == 'true'
        run: |
          echo "Cache hit - using cached package and dependencies"
          echo "Cached packages count: $(ls -1 dependency-cache/*.tgz 2>/dev/null | wc -l)"
          ls -la cached-packages/ dependency-cache/ | head -20

      - name: Check if package already exists in GitHub Packages
        id: check_github_package
        run: |
          # Use the sanitized name to check if the package exists
          if npm view @${{ github.repository_owner }}/${{ steps.sanitize_name.outputs.sanitized_name }}@${{ steps.resolve_version.outputs.resolved_version }} version > /dev/null 2>&1; then
            echo "Package already exists in GitHub Packages. Skipping publish."
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Package not found in GitHub Packages. Proceeding to publish."
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish Package to GitHub Packages
        if: steps.check_github_package.outputs.exists == 'false'
        run: |
          cd cached-packages/package
          echo "Publishing main package from extracted package directory"
          npm publish --ignore-scripts
          echo "Main package published to GitHub Packages successfully"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish All Dependencies to GitHub Packages
        run: |
          echo "Publishing all dependencies to GitHub Packages..."
          
          # Check if dependency-cache exists and has files
          if [ ! -d "dependency-cache" ]; then
            echo "No dependency-cache directory found, skipping dependency publishing"
            exit 0
          fi
          
          dep_count=$(ls -1 dependency-cache/*.tgz 2>/dev/null | wc -l)
          if [ "$dep_count" -eq 0 ]; then
            echo "No dependency packages found in cache, skipping dependency publishing"
            exit 0
          fi
          
          echo "Found $dep_count dependency packages to process"
          cd dependency-cache
          
          # List all .tgz files for debugging
          echo "Available .tgz files:"
          ls -la *.tgz 2>/dev/null || echo "No .tgz files found"
          
          # Create a script to process each dependency
          cat > publish_deps.js << 'EOF'
          const fs = require('fs');
          const { execSync } = require('child_process');
          const path = require('path');
          
          // Get list of all .tgz files
          const tgzFiles = fs.readdirSync('.').filter(f => f.endsWith('.tgz'));
          console.log(`Found ${tgzFiles.length} dependency packages to process`);
          
          if (tgzFiles.length === 0) {
            console.log('No .tgz files found in dependency-cache directory');
            process.exit(0);
          }
          
          let published = 0;
          let skipped = 0;
          let errors = 0;
          
          for (const tgzFile of tgzFiles) {
            try {
              console.log(`\nProcessing: ${tgzFile}`);
              
              // Check if file exists
              if (!fs.existsSync(tgzFile)) {
                console.log(`File ${tgzFile} does not exist, skipping...`);
                errors++;
                continue;
              }
              
              // Extract the package
              const extractDir = tgzFile.replace('.tgz', '-extract');
              execSync(`mkdir -p ${extractDir}`);
              execSync(`tar -xzf ${tgzFile} -C ${extractDir}`);
              
              // Read the package.json
              const packageDir = path.join(extractDir, 'package');
              const packageJsonPath = path.join(packageDir, 'package.json');
              
              if (!fs.existsSync(packageJsonPath)) {
                console.log(`No package.json found in ${packageDir}, skipping...`);
                skipped++;
                continue;
              }
              
              const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
              const originalName = pkg.name;
              
              // Skip if this is the main package (already handled separately)
              if (pkg.name === '${{ steps.sanitize_name.outputs.sanitized_name }}') {
                console.log(`Skipping main package ${pkg.name} (handled separately)`);
                skipped++;
                continue;
              }
              
              // Skip if already scoped to our organization
              if (pkg.name.startsWith('@${{ github.repository_owner }}/')) {
                console.log(`Package ${pkg.name} already scoped to our org, skipping...`);
                skipped++;
                continue;
              }
              
              // Create scoped name
              const scopedName = '@${{ github.repository_owner }}/' + pkg.name.split('/').pop();
              
              // Check if package already exists in GitHub Packages
              try {
                const checkCmd = `npm view ${scopedName}@${pkg.version} version --registry=https://npm.pkg.github.com`;
                execSync(checkCmd, { 
                  stdio: 'pipe', 
                  env: { ...process.env, NODE_AUTH_TOKEN: process.env.NODE_AUTH_TOKEN } 
                });
                console.log(`Package ${scopedName}@${pkg.version} already exists, skipping...`);
                skipped++;
                continue;
              } catch (e) {
                // Package doesn't exist, continue with publishing
                console.log(`Package ${scopedName}@${pkg.version} not found, will publish...`);
              }
              
              // Update package.json
              pkg.name = scopedName;
              pkg.publishConfig = { registry: 'https://npm.pkg.github.com' };
              
              if (!pkg.repository) {
                pkg.repository = {
                  type: 'git',
                  url: 'git+https://github.com/${{ github.repository }}.git'
                };
              }
              
              // Remove problematic scripts
              if (pkg.scripts) {
                const scriptsToRemove = ['test', 'prepublishOnly', 'prepack', 'postpack', 'prepare'];
                scriptsToRemove.forEach(script => {
                  if (pkg.scripts[script]) {
                    delete pkg.scripts[script];
                  }
                });
                Object.keys(pkg.scripts).forEach(scriptName => {
                  if (scriptName.includes('test') || scriptName.includes('build')) {
                    delete pkg.scripts[scriptName];
                  }
                });
              }
              
              // Write updated package.json
              fs.writeFileSync(packageJsonPath, JSON.stringify(pkg, null, 2));
              
              // Publish the package
              const originalCwd = process.cwd();
              process.chdir(packageDir);
              try {
                execSync('npm publish --ignore-scripts --registry=https://npm.pkg.github.com', { 
                  stdio: 'inherit',
                  env: { ...process.env, NODE_AUTH_TOKEN: process.env.NODE_AUTH_TOKEN }
                });
                console.log(`Successfully published: ${scopedName}@${pkg.version}`);
                published++;
              } catch (publishError) {
                console.error(`Failed to publish ${scopedName}@${pkg.version}:`, publishError.message);
                errors++;
              }
              
              process.chdir(originalCwd);
              
            } catch (error) {
              console.error(`Error processing ${tgzFile}:`, error.message);
              errors++;
            }
          }
          
          console.log(`\nPublishing complete:`);
          console.log(`- Published: ${published} packages`);
          console.log(`- Skipped: ${skipped} packages`);
          console.log(`- Errors: ${errors} packages`);
          
          if (published === 0 && errors > 0) {
            console.log('WARNING: No packages were published and there were errors.');
            console.log('This might indicate an issue with the dependency caching process.');
          }
          EOF
          
          # Run the publishing script
          node publish_deps.js
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Log Package Skipped
        if: steps.check_github_package.outputs.exists == 'true'
        run: |
          # Use the sanitized name in the log message
          echo "Skipping main package publish: @${{ github.repository_owner }}/${{ steps.sanitize_name.outputs.sanitized_name }}@${{ steps.resolve_version.outputs.resolved_version }} already exists in GitHub Packages."
          echo "Dependencies will still be processed and published if they don't exist."

      - name: Log Cache Status
        run: |
          if [ "${{ steps.cache_package.outputs.cache-hit }}" = "true" ]; then
            echo "Used cached package and dependencies from previous workflow run"
          else
            echo "Downloaded fresh package and all dependencies from NPM registry and cached for future runs"
          fi
          
          # Show summary of what was cached/processed
          echo "Summary of cached dependencies:"
          if [ -d "dependency-cache" ]; then
            dep_count=$(ls -1 dependency-cache/*.tgz 2>/dev/null | wc -l)
            echo "Total dependency packages cached: $dep_count"
            echo "Cached dependencies (first 10):"
            ls -1 dependency-cache/*.tgz 2>/dev/null | head -10 | sed 's/.*\//- /'
            if [ "$dep_count" -gt 10 ]; then
              echo "... and $((dep_count - 10)) more"
            fi
          else
            echo "No dependency cache directory found"
          fi
